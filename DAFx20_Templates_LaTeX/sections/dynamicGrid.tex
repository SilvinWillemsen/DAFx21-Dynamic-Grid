\section{The Dynamic Grid}
If we want to dynamically change parameters of our model, in this case the wave speed $c$, there are several aspects that need to be taken into account in a discrete setting. First of all, a change in $c$ causes a change in $\lambda$ according to Eq. \eqref{eq:compactLambda}, affecting the simulation quality and bandwidth. Secondly, and more importantly, a change in $c$ could result in a change in $N$ through Eq. \eqref{eq:numberOfIntervals}. As $N$ directly relates to the number of grid points, this raises questions as to \textit{where} and especially \textit{how} one would add and remove points to the grid according to the now-dynamic wave speed.

We propose a method that allows for a non-integer number of intervals to smoothly change between grid configurations, i.e, the number of grid points. This removes the necessity of the flooring operation in Eq. \eqref{eq:numberOfIntervals} and Eq. \eqref{eq:compactLambda}, and consequently satisfies the CFL condition in \eqref{eq:CFL} with equality at all times. Introducing fractional number of intervals $\Nfrac$, where $N = \lfloor \Nfrac\rfloor$, Eq. \eqref{eq:fundamentalFreqCont} can be rewritten in terms of $\Nfrac$ by substituting Eq. \eqref{eq:numberOfIntervals} into Eq. \eqref{eq:fundamentalFreqCont} (using Eq. \eqref{eq:stabilityCond} satisfied with equality) yielding
\begin{equation}\label{eq:fundamentalFreq}
    f_0 = \frac{1}{2\Nfrac k}\quad \text{with}\quad \Nfrac = L/h.
\end{equation}
This shows that if $\lambda = 1$, $\Nfrac$ solely determines the fundamental frequency of the simulation. 

% As mentioned in the previous section, the goal of this paper is to achieve real-time  parameter changes by dynamically changing grid configurations, in order to prevent undesirable behaviour such as a decrease in bandwidth and increase in numerical dispersion. % discussed in Section \ref{sec:quality}. %This section will describe the problems that arise when adding and removing grid points. Afterwards, some iterations done over the course of this project and their drawbacks will be shown, leading up to the final implementation of the dynamic grid. 

% The first questions that need to be answered are ``where to add points?" and ``how to add points?" The problems when doing this range from artifacts or auditory `clicks' in the output sound to ``exploding" systems due to artificial injection of energy. 
The rest of this section will list the requirements of a method that dynamically changes FDTD grid configurations. %Then, the iterations done over the course of this project will briefly be described, the details of each can be found in Appendix \ref{app:A}. \SWcomment[(I think I might remove the iterations and appendix actually..)] 
Then, the proposed method will be described in detail and summarised, and finally, some details on its implementation are given. 

\subsection{Method requirements}\label{sec:methodReq}
Ideally, a method that dynamically changes the grid size of finite-difference schemes should
\begin{enumerate}
    \item generate an output with a fundamental frequency $f_0$ %described by Eq. \eqref{eq:fundamentalFreq} 
    which is linearly proportional to the wave speed $c$ ($f_0 \propto c$),
    \item allow for a fractional number of intervals $\Nfrac$ to smoothly transition between different grid configurations% so that no auditory artefacts are present in the output sound,
    \item generate an output containing $ N-1$ modes which are integer multiples of the fundamental ($f_p = f_0 p$ with integer $p$),
    % \item generate an output with $\lfloor N\rfloor-1$ modes corresponding to the number of moving points of the system ($p = [1, \hdots, \allowbreak\lfloor N\rfloor-1]$),
    \item work in real time.
\end{enumerate}
The last requirement is added in order to have a playable simulation.
%
% The total amount of modes is expected to be equal to $N-1$ corresponding to the total number of moving grid points (points excluding the boundary).
%As the variables $c$, $h$, $\lambda$ and $N$ are now time-varying, a superscript $n$ or $n-1$ is added when necessary. If omitted, a time index $n$ is assumed.

% \subsection{Iterations \SWcomment[(optional section)]}\label{sec:iterations} 
% One method that could be used to go from one grid configuration to the next is full-grid interpolation as described in \cite[Chap. 5]{bilbao2009}. However, this method essentially has a lowpassing effect on the entire system state and can cause `clicks' in the output sound due to the interpolation. A (much) higher sample rate could be used to avoid these issues, but this would render this method impossible to work in real time.

% Another method is to add and remove points at the boundary using an interpolated boundary condition, the possibility of which has been briefly mentioned in \cite[p. 145]{bilbao2009}. If the boundary is fixed through Eq. \eqref{eq:contDirichlet}, the state at this location will always be $0$ and potentially allows for smooth entry and exit of grid points at this location. This method can be seen analogous to tuning a guitar string where string-material enters and leaves the playable part of the string at the nut, the boundary. The interpolated nature of the boundary does allow for a ``fractional" $N$ as described in Section \ref{sec:dynamicParams} and has a fundamental frequency calculated using \eqref{eq:fundamentalFreq}. %removing the flooring operation in Eq. \eqref{eq:compactLambda} and always satisfying the CFL condition with equality. \SWcomment[This has the added feature that $L/h$ in Eq. \eqref{eq:numberOfIntervals} is an integer and the flooring operation can be ignored. Substituting Eq. \eqref{eq:numberOfIntervals} into Eq. \eqref{eq:fundamentalFreqCont} (using Eq. \eqref{eq:stabilityCond} satisfied with equality) yields
%\begin{equation}%\label{eq:fundamentalFreq}
%     f_0 = \frac{1}{2Nk}\ ,
% \end{equation}
% which shows that if $\lambda = 1$, $N$, which is now not necessarily an integer, solely decides the fundamental frequency of the simulation.] 
% Although informal testing shows that adding points to the grid can happen smoothly, removing points smoothly is more challenging. This is due to the fact that the grid point at the boundary will be moving right before it is removed and its displacement needs to (somehow) smoothly be reduced to 0 to satisfy the fixed boundary condition in Eq. \eqref{eq:contDirichlet}. %\SWcomment[$\leftarrow$ if simply supported condition is mentioned here] Even though the $\delta_{xx}u$ part of this condition can be easily satisfied, the $u=0$ part can not.

\subsection{Proposed Method}\label{sec:proposedMethod}
% This section introduces the proposed method to dynamically and smoothly change the grid of FDSs to account for dynamic parameter changes. %To avoid the issues of adding and removing points at the boundary due to boundary conditions, they can be added or removed along the grid instead. \SWcomment[$\leftarrow$ Revise sentence if iterations are removed] For the sake of simplicity, the location is chosen to be the center of the system. %\SWcomment[At the end of this section, the location exhibiting the best behaviour will be shown.] 
In the following, the location of a grid point (in m from the left boundary) $i$ (such as $i = u_0$) at time index $n$ is denoted by $x_i^n$. 

\subsubsection{System Setup}\label{sec:systSetup}
Consider two grid functions, $u_\lu^n$ and $w_\lw^n$ defined over discrete domains $\lu = [0, \hdots, M]$ and $\lw = [0, \hdots, M_w]$ respectively with integers $M = \lceil 0.5L/ck\rceil $ with $\lceil \cdot \rceil$ denoting the ceiling operation and $M_w = \lfloor 0.5L/ck\rfloor$, i.e., half the number of points allowed by the stability condition, plus one for overlap. The grid functions can then be placed in line with each other on the same domain $x$ with $u_M^n$ and $w_0^n$ (defined as the inner boundaries) overlapping, i.e., $x_{u_M}^n = x_{w_0}^n = Mh$, and $u_0^n$ and $w_{M_w}^n$ (defined as the outer boundaries) located at $x_{u_0} = 0$ and $x_{w_{M_w}} = L$. See Figure \ref{fig:twoFreeStrings}. The following boundary conditions are then imposed:
\begin{subequations}\label{eq:halfStringBoundaryCond}
    \begin{align}
        u_0^n = w_{M_w}^n &= 0,\quad \text{(Dirichlet)}\label{eq:halfStringBoundaryCondDirichlet}\\
        \delta_{x\cdot}u_M^n = \delta_{x\cdot}w_0^n &= 0.\, \quad\text{(Neumann)}, \label{eq:halfStringBoundaryCondNeumann}
    \end{align}
\end{subequations}
i.e., the outer boundaries are fixed and the inner boundaries are free.
% \begin{figure}[h]
% \centerline{\includegraphics[width=\columnwidth]{twoFreeStrings.eps} }
% \caption{\label{fig:twoFreeStrings}{Two (1D wave) systems connected at one of their boundaries.}}
% \end{figure}
%
% \baselineskip=12pt
%
The systems can then be connected at the inner boundaries using a rigid connection
\begin{equation}\label{eq:rigid}
    u_M^n = w_0^n,\quad \forall n.
\end{equation}
To sum up, a grid function with $N$ intervals as per Eq. \eqref{eq:numberOfIntervals} is divided into two separate subsystems connected at their respective inner boundaries. 

With the above boundary conditions imposed, the following state vectors can be defined:
\begin{equation}
    % \begin{aligned}
    \label{eq:separateStateVectors}
     \mathbf{u}^n = [u_1^n, \hdots, u_M^n]^T\!, \  \text{and} \ \; \mathbf{w}^n = [w_0^n, \hdots, w_{M_w-1}^n]^T,
    % \end{aligned}
\end{equation}
with $T$ denoting the transpose operation, and have $M$ and $M_{w}$ points respectively. Note that the outer boundaries are excluded as they are 0 at all times. The vector concatenating \eqref{eq:separateStateVectors} is then defined as 
\begin{equation}\label{eq:fullState}
    \U^n = \begin{bmatrix}
        \mathbf{u}^n \\
        \mathbf{w}^n
    \end{bmatrix}.
\end{equation}
Note that the vectors in \eqref{eq:separateStateVectors} and \eqref{eq:fullState} also exist at the next ($n+1$) and previous ($n-1$) time indices. 

Even though the new system has an extra (overlapping) grid point, the behaviour of the new system should be identical to that of the original system. That this holds will be shown below.

Using $u_\lu^n$ and $w_\lw^n$ in the context of the 1D wave equation, a system of FDSs can be defined as
\begin{equation}
    \begin{cases}\label{eq:systemHalfStrings}
        \delta_{tt}u_\lu^n = c^2\delta_{xx}u_\lu^n + J_u(x_{u_M}^n)F\\
        \delta_{tt}w_\lw^n = c^2\delta_{xx}w_\lw^n - J_w(x_{w_0}^n)F
    \end{cases}
\end{equation}
with spreading operators
\begin{equation}\label{eq:spreadingOperators}
    \begin{aligned}
    J_u(x_i)& =
    \begin{cases}
        \frac{1}{h}, & \lu = \lu_{\!,i} = \lfloor x_i/h\rfloor\\
        0,& \text{otherwise}
    \end{cases}
    \quad\text{and}\\
    J_w(x_i) &=
    \begin{cases}
        \frac{1}{h}, & \lw = \lw_{\!,i} = \lfloor x_i/h \rfloor - M\\
        0,& \text{otherwise}
    \end{cases}
\end{aligned}
\end{equation}
applying the effect of the connection %\SWcomment[(``connection force", but not really as it isn't in N)] 
$F$ (in m$^2/$s$^2$) to grid points $u_M^n$ and $w_0^n$ respectively.
%
Expanding the spatial operators in system \eqref{eq:systemHalfStrings} at inner boundaries $u_M^n$ and $w_0^n$, recalling the Neumann condition in  \eqref{eq:halfStringBoundaryCondNeumann} and the definition for the virtual grid points needed for this condition in Eq. \eqref{eq:neumannSolution} yields
\begin{equation}\label{eq:expandedSystem}
    \begin{cases}
        \delta_{tt}u_M^n = \frac{c^2}{h^2}(2u_{M-1}^n-2u_M^n) + \frac{1}{h}F\\
        \delta_{tt}w_0^n = \frac{c^2}{h^2}(2w_1^n-2w_0^n) - \frac{1}{h}F.
    \end{cases}
\end{equation}
Because of Eq. \eqref{eq:rigid}, it is also true that $\delta_{tt}u_M^n = \delta_{tt}w_0^n, \ \forall n$, and $F$ can be calculated by setting the right side of the equations in \eqref{eq:expandedSystem} equal to each other:
\begin{align*}
     \frac{c^2}{h^2}(2u_{M-1}^n-2u_M^n) + \frac{1}{h} F&= 
     \frac{c^2}{h^2}(2w_1^n-2w_0^n) - \frac{1}{h} F\nonumber\\
    % \frac{2}{h}F &= \frac{c^2}{h^2}(2w_1^n - 2u_{M-1}^n)\nonumber\\
    F &= h \frac{c^2}{h^2}(w_1^n - u_{M-1}^n).
\end{align*}
Substituting this into system \eqref{eq:expandedSystem} after expansion of the second-time derivative yields the update of the inner boundaries
% \begin{equation}
\begin{subnumcases}{\!\!\!\!\!\!\!\!\!\!\!\!\!\!\label{eq:resultOneConnectedPoint}}
    u^{n+1}_M = 2u_M^n - u_M^{n-1} + \lambda^2(u_{M-1}^n-2u_M^n+w_1^n)\label{eq:resultUM}\\
    w^{n+1}_0 = 2w_0^n - w_0^{n-1} + \lambda^2(u_{M-1}^n-2w_0^n+w_1^n)\label{eq:resultw0}
\end{subnumcases}
% \end{equation}
which, (again, recalling Eq. \eqref{eq:rigid}) are indeed equivalent expressions for the connected point and is necessary to satisfy the rigid connection. This system can be shown to exhibit behaviour identical to that of the original system. In \eqref{eq:resultOneConnectedPoint}, $w_1^n$ in Eq. \eqref{eq:resultUM} acts as virtual grid point $u_{M+1}^n$ and $u_{M-1}^n$ in \eqref{eq:resultw0} as virtual grid point $w_{-1}^n$%, essentially connecting the two systems using the state of one in the update of the other
. This important fact is what the method relies on and will be extensively used in the following.

\def\figwidth{1.0}
\begin{figure}[ht!]
    \centering
    \subfloat[]{\label{fig:twoFreeStrings}{ \includegraphics[width=\figwidth\columnwidth]{Figures/twoFreeStringsNarrow.eps}}}\\
    \vspace{-1em}\subfloat[]{\label{fig:twoFreeStringsGridMove}{ \includegraphics[width=\figwidth\columnwidth]{Figures/twoFreeStringsGridMoveNarrow.eps}}}\\
    \vspace{-1em}\subfloat[]{\label{fig:twoFreeStringsGridZoomed}{ \includegraphics[width=\figwidth\columnwidth]{Figures/twoFreeStringGridMoveZoomedNarrow.eps}}}
    \vspace{-1em}\caption{Illustration of the proposed method. In all figures, the x-axis shows the location of the respective grid points%(fx. $x_{u_l^n}$)
    , but the $x$ and $n$ are omitted for brevity. (a) Locations of the states of two (1D wave) systems connected at the inner boundaries ($\Nfrac = 30$, $x_{u_M}^n = x_{w_0}^n$). (b) When $c$ -- and consequently $h$ -- are decreased and the positions of the grid points change ($\Nfrac = 30.5$, $x_{u_M}^n \neq x_{w_0}^n$). (c) Figure \ref{fig:twoFreeStringsGridMove} zoomed-in around the inner boundaries. The virtual grid points $u_{M+1}^n$ and $w_{-1}^n$ are shown together with the distance between them expressed using $\alpha$ in Eq. \eqref{eq:alphaDef}.\SWcomment[if $\lu$ and $\lw$ are going to be used, don't forget to change in figures (a) and (b)!]}
\end{figure}

\subsubsection{Changing the Grid}\label{sec:changingGrid}
The previous section describes the case in which the stability condition is satisfied with equality, i.e, when $L/ck$ is an integer% and $x_{u_M}^n = x_{w_0}^n$
. The locations of the outer boundaries $x_{u_0}^n$ and $x_{w_{M_w}}^n$ are fixed, i.e.
\begin{equation*}
    x_{u_0}^n = x_{u_0}^0 = 0 \quad \text{and}\quad x_{w_{M_w}}^n = x_{w_{M_w}}^0 = L \quad \forall n.
\end{equation*}
If the wave speed $c$ is then decreased, and consequently the grid spacing $h$ according to Eq. \eqref{eq:stabilityCond} (with equality), all other points move towards their respective outer boundary (see Figure \ref{fig:twoFreeStringsGridMove}). Calculating $h$ this way allows this method to always satisfy the CFL condition in Eq. \eqref{eq:CFL} with equality. %, as is the case with the previous iteration described in \ref{sec:iterations}.

% \begin{figure}[h]
% \centerline{\includegraphics[width=\columnwidth]{twoFreeStringGridMove} }
% \caption{\label{fig:twoFreeStringsGridMove}{When the grid changes ($\Nfrac = 30.5$). The x-axis shows the location (in m) of the respective grid points (fx. $x_{u_l^n}$), but the $x$ is omitted for clarity.}}
% \end{figure}

As mentioned in Section \ref{sec:systSetup}, the state of the virtual grid points at the inner boundaries are defined as $u_{M+1}^n = w_1^n$ and $w_{-1}^n = u_{M-1}^n$ when the inner boundaries are perfectly overlapping  (i.e., $x^n_{u_M} = x^n_{w_0}$). If this is not the case (i.e., $x^n_{u_M} \neq x^n_{w_0}$) a Lagrangian interpolator $I(x_i)$ at location $x_i$ from the left boundary (in m) can be used to calculate the value of these virtual grid points (also see Figure \ref{fig:twoFreeStringsGridZoomed} for reference). The interpolator $I$ is a row-vector the same length as $\mathbfcal{U}^n$ (from Eq. \eqref{eq:fullState}) its values depending on what interpolation order is used. In the following the fractional part of $\Nfrac$ %distance between the inner boundaries normalised by $h$ 
is defined as 
\begin{equation}\label{eq:alphaDef}
    \alpha = \alpha^n = \Nfrac^n - N^n %\frac{x^n_{w_0} - x^n_{u_M}}{h}\,,
\end{equation}
and for clarity, $I$ and $\mathbfcal{U}^n$ are indexed by $m$.
%\SWcomment[it's possible to skip until quadratic interpolation straight away from here, skipping the iterations] In the following, the distance between the inner boundaries normalised with $h$ is defined as
% \begin{equation}\label{eq:alphaDef}
%     \alpha = \alpha^n = \frac{x^n_{w_0} - x^n_{u_M}}{h}\,,
% \end{equation}
% and for clarity, $I$ and $\mathbfcal{U}^n$ are indexed by $m$.
% Applying the interpolator to $\mathbfcal{U}^n$ yields
% \begin{subequations}\label{eq:interpolationGeneral}
%     \begin{align}
%         u_{M+1}^n &= I^\flip(x^n_{u_{M+1}})\mathbfcal{U}^n% = (1-\alpha)w_1^n + \alpha w_0^n
%         \\
%         w_{-1}^n &= I(x^n_{w_{-1}})\mathbfcal{U}^n,% = (1-\alpha)u_{M-1}^n + \alpha u_M^n
%     \end{align}
% \end{subequations}
% where $I^\flip$ is a flipped and shifted version of $I$.
% % where
% % \begin{equation}
% %     \alpha = \frac{x_{w_0} - x_{u_M}}{h},
% % \end{equation}
% % and grid-point locations $x_{u_{M+1}}$ and $w_{-1}$. Note that when $h$ changes the connected points start to move away from each other.
% %
% If linear interpolation is used, 
% \begin{subequations}\label{eq:linearInterp}
% \begin{equation}
%     I_1(x_i) = 
%     \begin{cases}
%         (1-\alpha), & m = m_i \\
%         \alpha, & m = m_i + 1\\
%         0, & \text{otherwise}
%     \end{cases}
% \end{equation}
% and
% \begin{equation}\label{eq:linearFlip}
%     I_1^\flip(x_i) = 
%     \begin{cases}
%         \alpha, & m = m_i^\flip \\
%         (1-\alpha), & m = m_i^\flip + 1\\
%         0 & \text{otherwise}
%     \end{cases}
% \end{equation}
% \end{subequations}
% with $m_i = \lfloor x_i/h\rfloor$ and $m_i^\flip = \lfloor x_i/ h+(1-\alpha) \rfloor$, where the shift in the latter is necessary to transform the location $x_i$ to the right indices of $\mathbfcal{U}^n$. Substituting \eqref{eq:linearInterp} into \eqref{eq:interpolationGeneral} and expanding yields
% \begin{subequations}
%     \begin{align}
%         u_{M+1}^n &= I_1^\flip(x^n_{u_{M+1}})\mathbfcal{U}^n = \alpha w_0^n
%         + (1-\alpha)w_1^n,\\
%         w_{-1}^n &= I_1(x^n_{w_{-1}})\mathbfcal{U}^n = (1-\alpha)u_{M-1}^n + \alpha u_M^n.
%     \end{align}
% \end{subequations}
% % \begin{figure}[h]
% % \centerline{\includegraphics[width=\columnwidth]{twoFreeStringGridMoveZoomed} }
% % \caption{\label{fig:twoFreeStringsGridZoomed}{When the grid changes (zoomed). The states at the inner boundaries $u_M$ and $w_0$ are shown together with virtual grid points $u_{M+1}$ and $w_{-1}$.}}
% % \end{figure}
% %
% Using $I_1$, analysis of the output shows that the expected fundamental frequency $f_0$ is slightly higher when interpolation needs to happen than the one expected when using Eq. \eqref{eq:fundamentalFreq}. Furthermore, modes higher than $f_\text{s} / 4$ would follow an odd pattern up when decreasing the wave speed, opposite of what is expected. \SWcomment[$\leftarrow$ didn't know where (or whether) to include this.]

% One could extend the range of interpolation by one point to each side, using a cubic Lagrange interpolator instead. Although this would require $w_{-1}^n$ to calculate $u_{M+1}^n$ and vice versa, it is possible to solve this by treating the interpolation equations as a system of linear equations. Analysis of this method, though yielding a correct $f_0$ at all times, shows similar behaviour to the linear interpolation, with odd behaviour regarding modes higher than $f_\text{s}/4$.

% Much better behaviour is observed when points of both $u_l^n$ and $w_l^n$ are used to calculate the values of the virtual grid points. This means to also use $u_M^n$ to calculate $u_{M+1}^n$ and $w_0^n$ for $w_{-1}^n$. Now, the locations of the grid points used in the interpolation are not equidistant and a custom Lagrangian interpolator needs to be created. The lowest order interpolator that can be used here is the quadratic interpolator $I_2$
%
The best behaviour is observed when $I$ is even-ordered (odd-ordered interpolation results in higher-frequency modes %crossing and
increasing as $c$ decreases and vice-versa). Although higher orders yield slightly better behaviour this improvement is negligible and the lowest even-ordered, quadratic interpolation, already yields good results. The quadratic interpolator $I_2$ is defined as
\begin{subequations}\label{eq:quadInterp}
\begin{equation}\label{eq:quadNonFlip}
    I_2(x_i) =
    \begin{cases}
        -(\alpha-1)/(\alpha + 1), & m = m_i-1\\
        1, & m = m_i\\
        (\alpha-1)/(\alpha + 1), & m = m_i+1\\
        0, & \text{otherwise}
    \end{cases}
\end{equation}
and its flipped version as
\begin{equation}\label{eq:quadFlip}
    I_2^\flip(x_i) = 
    \begin{cases}
        (\alpha-1)/(\alpha + 1), & m = m_i^\flip-1\\
        1, & m = m_i^\flip\\
        -(\alpha-1)/(\alpha + 1), & m = m_i^\flip+1\\
        0, & \text{otherwise}
    \end{cases}
\end{equation}
\end{subequations}
with $m_i = \lfloor x_i/h\rfloor$ and $m_i^\flip = \lfloor x_i/ h+(1-\alpha) \rfloor$, where the shift in the latter is necessary to transform the location $x_i$ to the right indices of $\mathbfcal{U}^n$.
When applied to Eq. \eqref{eq:fullState} this yields the definitions for the virtual grid points
\begin{subequations}\label{eq:connectionInterpol}
\begin{align}
        &u_{M+1}^n = I_2^\flip(x^n_{u_{M+1}})\mathbfcal{U}^n = \frac{\alpha - 1}{\alpha + 1}u_{M}^n + w_0^n - \frac{\alpha - 1}{\alpha + 1}w_1^n
    \label{eq:calcUMP1}\\
        &w_{-1}^n = I_2(x^n_{w_{-1}})\mathbfcal{U}^n
        =-\frac{\alpha - 1}{\alpha + 1}u_{M-1}^n + u_{M}^n+ \frac{\alpha - 1}{\alpha + 1}w_{0}^n.\label{eq:calcWM1}
\end{align}
\end{subequations}
% where
% \begin{equation}\small
% \begin{gathered}\label{eq:interpolationCoeffs}
%     \alpha_\text{I} = \frac{\alpha(\alpha - 1)(\alpha - 2)}{-6}, \quad \beta_\text{I} = \frac{(\alpha - 1)(\alpha + 1)(\alpha - 2)}{2},\\
%     \gamma_\text{I} = \frac{\alpha(\alpha + 1)(\alpha - 2)}{-2}, \quad \text{and} \quad\delta_\text{I} = \frac{\alpha(\alpha + 1)(\alpha - 1)}{6}\,.
% \end{gathered}
% \end{equation}
% Treating \eqref{eq:connectionInterpol} as a system of linear equations, the virtual grid points $u_{M+1}^n$ and $w_{-1}^n$ can be solved for using
% \begin{equation}\label{eq:linSystSolution}
%     \begin{bmatrix}
%     u_{M+1}^n \\
%     w_{-1}^n
%     \end{bmatrix}
%     =
%     \mathbfcal{A}\begin{bmatrix}
%     \alpha_\text{I} w_2^n+ \beta_\text{I}w_1^n + \gamma_\text{I}w_0^n \\
%     \alpha_\text{I} u_{M-2}^n + \beta_\text{I}u_{M-1}^n + \gamma_\text{I} u_{M}^n
%     \end{bmatrix},
% \end{equation}
% where
% \begin{equation}\label{eq:Amat}
%     \mathbfcal{A} = \begin{bmatrix}
%          1 & -\delta_\text{I} \\
%          -\delta_\text{I} & 1
%     \end{bmatrix}^{-1}.\nonumber
% \end{equation}
% where
% \begin{equation}\nonumber
%     \mathbfcal{A} = \begin{bmatrix}
%          1 & -\delta_\text{I} \\
%          -\delta_\text{I} & 1
%     \end{bmatrix},
% \end{equation}
% and
% \begin{equation}\nonumber
%     \mathbf{v} = \begin{bmatrix}
%     \alpha_\text{I} w_2^n+ \beta\text{I}w_1^n + \gamma\text{I}w_0^n \\
%     \alpha_\text{I} u_{M-2}^n + \beta\text{I}u_{M-1}^n + \gamma u_{M}^n
%     \end{bmatrix}.
% \end{equation}
As will be shown in Section \ref{sec:results}, quadratic interpolation yields the expected fundamental frequency at all times. One can show that when $\Nfrac$ is an integer, and thus $\alpha = 0$, Eqs. \eqref{eq:calcUMP1} and \eqref{eq:calcWM1} can be substituted as $w_1^n$ and $u_{M-1}^n$ into Eqs. \eqref{eq:resultUM} and \eqref{eq:resultw0} respectively (as these acted as virtual grid points $u_{M+1}^n$ and $w_{-1}^n$). Then recalling Eq. \eqref{eq:rigid} it can be seen that the system reduces to \eqref{eq:resultOneConnectedPoint} and exhibits the same exact behaviour as the normal case. % also when interpolation needs to happen.
Rewriting system \eqref{eq:systemHalfStrings} to include this yields
\begin{equation}\label{eq:FDSwithMethod}
    \begin{cases}
        \delta_{tt}u_\lu^n = c^2\delta_{xx}u_\lu^n + J_u(x_{u_M}^n)2c^2\delta_{x\cdot}u_M^n\\
        \delta_{tt}w_\lw^n = c^2\delta_{xx}w_\lw^n - J_w(x_{w_0}^n)2c^2\delta_{x\cdot}w_0^n
    \end{cases}
\end{equation}
where the definitions for the virtual grid points from the second term are defined by the Neumann boundary condition in Eq. \eqref{eq:discreteNeumann} and those from the last terms are found in Eqs. \eqref{eq:connectionInterpol}.

\subsubsection{Adding and removing Grid Points}
When $c$, and consequently $h$, is decreased and the inner boundary points surpass the virtual points (i.e. $x_{u_M}^n \leq x_{w_{-1}}^n$ and $x_{w_0}^n \geq x_{u_{M+1}}^n$ or $
\alpha \geq 1$) and $N^n >  N^{n-1}$, a point is added to the right boundary of $u$ and the left boundary of $w$ (for both time indices $n$ and $n-1$) in an alternating fashion \SWcomment[as the best way turns out to be adding/removing close to the boundary to $\mathbf{u}$ (or $\mathbf{w}$) only (as described in the paragraph right before Section \ref{sec:dispCorr}), maybe this can be shortened/rewritten]: 
\begin{equation}\label{eq:addingPoint}
        \begin{cases}\mathbf{u}^n = [\mathbf{u}^n, I_3\mathbf{v}^n]^T & \text{if $N^n $ is odd},\\
        \mathbf{w}^n = [I_3^\flip\mathbf{v}^n, \mathbf{w}^n]^T & \text{if $ N^n$ is even},
        \end{cases}
\end{equation}
where 
\begin{align*}
\mathbf{v}^n = [u_{M-1}^n, u_M^n, w_0^n, w_1^n]^T,% \quad\text{and}\\
%     \mathbf{v}_\star^n &= [w_1^n, w_0^n, u_M^n, u_{M-1}^n],
\end{align*}
and cubic Lagrangian interpolator
\begin{equation}\label{eq:customIp}
    I_3 = \begin{bmatrix} -\frac{\alpha(\alpha+1)}{(\alpha+2)(\alpha+3)} &\frac{2\alpha}{\alpha+2} &\frac{2}{\alpha+2} 
    &-\frac{2\alpha}{(\alpha+3)(\alpha+2)}
    \end{bmatrix},
\end{equation}
with $I_3^\flip$ being just a flipped, not shifted, version of \eqref{eq:customIp}.
%with
% \begin{equation*}
%     \alpha' = \frac{x_{w_0}^n - (x_{u_M}^n + h)}{h}\ .
% \end{equation*}
See Figure \ref{fig:addingPoint}.
% Note that this operation is done for both time indices $n$ and $n-1$.
%
\begin{figure}[ht]
    \centering
%% \reprintcolumnwidth is the same in preprint and reprint for
%% ease of use for authors:
\includegraphics[width=\figwidth\columnwidth]{Figures/addingGridPoint4.eps}
\caption{\label{fig:addingPoint}{The moment when a point is added to $\mathbf{u}$ at location $x_{u_M} + h$ in Eq. \eqref{eq:addingPoint}. This figure shows an extreme case where this location is far from $x_{w_0}$, i.e., $\alpha' \not\approx 0$ in Eq. \eqref{eq:customIp}.}}
\end{figure}
%
Note, that except in the case of extremely quick parameter variations, $\alpha$ in Eq. \eqref{eq:customIp} is expected to be close to zero%, i.e., $x_{u_M}^n + h \approx x_{w_0}^n$,
meaning that $I_3 \approx [0, 0, 1, 0]$. %This makes sense by looking at Figure \ref{fig:twoFreeStringsGridZoomed}, as exactly when the boundary points $u_M^n$ and $w_0^n$ surpass the virtual points $w_{-1}^n$ and $u_{M+1}^n$, these are going to be close to overlapping.

Removing grid points happens when $c$, and consequently $h$, is increased and $x_{u_M}^n \geq x_{w_0}^n$ (or $ N^n <  N^{n-1}$). %Compared to adding grid points, removing these is slightly more straightforward as points 
Grid points are simply removed from $\mathbf{u}$ and $\mathbf{w}$ (again for both $n$ and $n-1$) in an alternating fashion according to
\begin{equation}\label{eq:removingPoint}
\begin{cases}
    \mathbf{u}^n = [u_0^n, u_1^n ..., u_{M-1}^n]^T & \text{if $N^n$ is even}, \\
     \mathbf{w}^n = [w_1^n, w_2^n ..., w_{M_w}^n]^T & \text{if $N^n$ is odd}.
    \end{cases}
\end{equation}

Until now, only adding and removing points in the center of the system has been considered. This location could be moved anywhere along the grid, the limit being one point from the boundary. In other words, both $u_\lu^n$ and $w_\lw^n$ need to have at least one point (excluding the outer boundaries). Furthermore, one does not have to add and remove points from $\mathbf{u}$ and $\mathbf{w}$ in an alternating fashion as in \eqref{eq:addingPoint}, but can just add and remove from (fx.) $\mathbf{u}$ leaving $\mathbf{w}$ the same size throughout the simulation. In the extreme case where $M = N - 1$ and $M_w = 1$ (leaving $w_\lw^n$ with only one moving grid point, $w_0^n$) the method still works.

\subsubsection{Displacement correction}\label{sec:dispCorr}
A problem that arises from increasing $h$, is that it is possible that $u_M^n \not\approx w_0^n$ at the time when a grid point needs to be removed. As $x_{u_M}^n \approx x_{w_0}^n$ at the time of removal (except for extremely quick parameter variations), this violates the rigid connection in \eqref{eq:rigid} and causes audible artefacts. A method is proposed that decreases the relative displacement of the inner boundaries the closer their grid-locations are together, i.e., the closer $\alpha$ in \eqref{eq:alphaDef} is to 0. We thus extend system \eqref{eq:FDSwithMethod} regular case as
\begin{equation}\label{eq:sysDispCorr}
\begin{cases}
    \delta_{tt}u_\lu^n = c^2\delta_{xx}u_\lu^n+ J_u(x_{u_M}^n)\left(2c^2\delta_{x\cdot}u_M^n + F_\text{c}\right)\\
    \delta_{tt}w_\lw^n = c^2\delta_{xx}w_\lw^n - J_w(x_{w_0}^n)\left(2c^2\delta_{x\cdot}w_0^n+F_\text{c}\right)
\end{cases}
\end{equation}
Furthermore, using centered temporal averaging and first-order difference operators
\begin{align}\label{eq:centeredAverage}
    \mu_{t\cdot}\ugen_l^n &= \frac{1}{2} \left(\ugen_l^{n+1} + \ugen_l^{n-1}\right)\\
    \delta_{t\cdot}\ugen_l^n &= \frac{1}{2k} \left(\ugen_l^{n+1} - \ugen_l^{n-1}\right)
\end{align}
the correction effect (in m$^2/$s$^2$) is modelled as a spring-like connection and is defined as
\begin{equation}\label{eq:dispCorrForce}
    F_\text{c} = \beta \left(\omega_0^2\mu_{t\cdot}\eta^n +\sigma_0\delta_{t\cdot}\eta^n \right).
\end{equation}
with the difference in displacement between the inner boundaries
\begin{equation}
    \eta^n \triangleq w_0^n - u_M^n 
\end{equation}
(in m), (angular) frequency of the spring $\omega_0$ (in s$^{-1}$) and damping coefficient $\sigma_0$ (in s$^{-1}$). Furthermore, $\beta = \beta(\alpha)$ scales the effect of the displacement correction and is defined as
\begin{equation}\label{eq:betaDef}
    \beta = \frac{1-\alpha}{\alpha + \varepsilon}\ ,
\end{equation}
where $\varepsilon \ll 1$ prevents a division by 0. Despite Eq. \eqref{eq:centeredAverage}, it is possible to calculate the force explicitly (such as in \cite{bilbao2009} or \cite{bilbao2009Dafx}). Furthermore, it can be shown that this calculation is defined, even for $\alpha  = \varepsilon = 0$ which acts as a rigid connection such as Eq. \eqref{eq:rigid}.
%$\beta$ can be seen as a spring force pulling the inner boundaries to the average displacement between them. A lower $\varepsilon$ decreases the chance of artifacts but will have a greater filtering effect on the system. For low-speed changes, using $\sim 1000$ samples for removing one grid point, $\varepsilon \approx 30$ ensures that $u_M^n \approx w_0^n$ at the time of removal and already suffices to remove artefacts.

% 
% \SWcomment[The following applies to odd-ordered Lagrange interpolators $\rightarrow$] The location at where points are added and removed greatly influences the behaviour of the system, especially in the higher frequencies (see Section \ref{sec:results}). The best behaviour is obtained when the location is as close to a boundary as possible. 

\subsection{Summary}
Here, Section \ref{sec:proposedMethod} is summarised and describes the final version of the proposed method.

The proposed method subdivides a grid function $\ugen_l^n$ with $ N+1$ grid points into two grid functions $u_\lu^n$ and $w_\lw^n$ with $M+1$ and $M_w+1$ grid points respectively for a total of $N+2$ grid points. Knowing that $\lambda=1\ \forall n$, Eq. \eqref{eq:updateEq}, written for both grid functions, becomes 
\begin{subequations}\label{eq:uwUpdates}
    \begin{align}
        u_\lu^{n+1} &= u_{\lu+1}^n + u_{\lu-1}^n - u_\lu^{n-1},\label{eq:uUpdate}\\
        w_\lw^{n+1} &= w_{\lw+1}^n + w_{\lw-1}^n - w_\lw^{n-1}\label{eq:wUpdate}.
    \end{align}
\end{subequations}
%
Due to the Dirichlet boundary condition in \eqref{eq:discreteDirichlet} imposed on the outer boundaries of the system, $u_0^n$ and $w_{M_w}^n$ are $0$ at all times and do not have to be included in the calculation. The ranges of calculation for Eq. \eqref{eq:uUpdate} and \eqref{eq:wUpdate} then become $\lu = [1, \hdots, M]$ and $\lw = [0, \hdots, M_w - 1]$ respectively. 

The inner boundaries are calculated by expanding \eqref{eq:FDSwithMethod} (ignoring the displacement correction for now)
\begin{subequations}\label{eq:innerboundariesExpanded}
    \begin{align}
        u_M^{n+1} &= u_{M+1}^n + u_{M-1}^n - u_M^{n-1},\\
        w_0^{n+1} &= w_{-1}^n + w_{1}^n - w_0^{n-1}.
    \end{align}
\end{subequations}
%
where virtual grid points $u_{M+1}^n$ and $w_{-1}^n$ can be calculated using Eq. \eqref{eq:connectionInterpol}.

Then, when $ N^n > N^{n-1}$ a point is added to $\mathbf{u}^n$ and $\mathbf{u}^{n-1}$ (or $\mathbf{w}^n$ and $\mathbf{w}^{n-1}$) using Eq. \eqref{eq:addingPoint}, and when $ N^n  < N^{n-1} $ a point is removed from the same vectors using Eq. \eqref{eq:removingPoint}. In order to prevent audible artefacts when increasing $c$ (and thus decreasing $\Nfrac$), a method in \eqref{eq:sysDispCorr} is proposed to ensure that the inner boundaries have a similar displacement when one of them is removed. 

Finally, using $\mathbfcal{U}$ from Eq. \eqref{eq:fullState} the total system can be compactly written in matrix form as
\begin{equation}\label{eq:totalSystem}
    \mathbf{C}_+\mathbfcal{U}^{n+1} = 
    \mathbf{B}
    \mathbfcal{U}^n
    + \mathbf{C}_-\mathbfcal{U}^{n-1}
\end{equation}
with $ N \times N$ matrices
\begin{equation}\label{eq:bMat}
    \mathbf{B} = 
    % \begingroup % keep the change local
    % \setlength\arraycolsep{2pt}
    \begin{bmatrix}[cccc|cccc]
        & \ddots  &\ddots & & & & 0 & \\
          & 1 & 0 & 1 & & & & \\
         & & 1 & \frac{\alpha - 1}{\alpha + 1} & 1  & -\frac{\alpha - 1}{\alpha + 1} & \\ \cline{2-7}
         & & -\frac{\alpha - 1}{\alpha + 1} & 1  & \frac{\alpha - 1}{\alpha + 1}  & 1 & & \\
            & & & &1 & 0 & 1  \\
            & 0 & &  &  &\ddots & \ddots &
       \end{bmatrix}
    %    \endgroup
\end{equation}
containing the effect of the general method described in Section \ref{sec:changingGrid} and
\begin{equation}\label{eq:CMat}
    \mathbf{C}_\pm = \pm\left(\mathbf{I} - \frac{\beta k^2 (\omega_0^2\pm\sigma_0/k)}{2}\mathbf{J}\boldsymbol{\eta}\right)
\end{equation}
containing the effect of the displacement correction described in Section \ref{sec:dispCorr} where $\mathbf{I}$ is the $ N \times N$ identity matrix and 
\begin{equation}
    \mathbf{J} = [\mathbf{0}_{M-1}, 1/h, -1/h, \mathbf{0}_{M_w-1}]^T
\end{equation}
and 
\begin{equation}
    \boldsymbol{\eta} = [\mathbf{0}_{M-1}, -1, 1, \mathbf{0}_{M_w-1}]
\end{equation}
are vectors of length $ N$ and $\boldsymbol{0}_i$ is a zero-vector of length $i$.
%
% \begin{equation}\small
%     \mathbf{B} = \begin{bmatrix}[ccccccc|cc]
%     & &\ddots &\ddots & \ddots  & & \mathbf{0} & & \\
%      & & &1 & 0 & 1 & & \mathbf{0} & \\
%      & & &  & 1 & 0 & 1 & & \\
%      & &\mathbf{0} &  & \mathbfcal{A}_{1, 2}\alpha_\text{I} &\mathbfcal{A}_{1, 2}\beta_\text{I} + 1 &\mathbfcal{A}_{1, 2}\gamma_\text{I} & \mathbfcal{A}_{1, 1}(\gamma_\text{I}-\alpha_\text{I})& \\ \cline{2-8}
%      & & \mathbf{0} & &\mathbfcal{A}_{2, 2}\alpha_\text{I} &\mathbfcal{A}_{2, 2}\beta_\text{I}&\mathbfcal{A}_{2, 2}\gamma_\text{I} & \mathbfcal{A}_{2,1}(\gamma_\text{I} - \alpha_\text{I}) & 
%     \end{bmatrix}
% \end{equation}
%
Notice that as $\alpha$ approaches $1$, $\mathbf{B}$ reduces to a matrix with ones on the diagonals next to the main diagonal and zeros elsewhere, which translates directly to the normal case in Eq. \eqref{eq:updateEq} with $\Nfrac = M + M_w + 1$. 

\subsection{Implementation}
Algorithm \ref{alg:calcOrder} shows the order of calculation to implement the method presented in this paper. Important is to only retrieve a change in $c$ at time index $n$ before all other, so that $u_\lu^n$ and $w_\lw^n$ are calculated with the same $\alpha$ and $\beta$ time index $n$ for all $\lu$ and $\lw$.
\begin{algorithm}[ht]
    \setstretch{1.1}
    \fbox{\parbox{0.8\linewidth}
    {
        \While{application is running}
        {
            \begin{minipage}[c]{0.9\linewidth}
                Retrieve new $c$\\
                Calc. $h$ (Eq. \eqref{eq:stabilityCond} with equality)\\
                Calc. $\Nfrac^n$ and $N^n$ (Eqs. \eqref{eq:fundamentalFreq} and \eqref{eq:numberOfIntervals}) \\
                Calc. $\alpha$ (Eq. \eqref{eq:alphaDef})\\
                \If{$ N^n \neq N^{n-1} $}
                {
                    Add or remove point (Eq. \eqref{eq:addingPoint} or \eqref{eq:removingPoint})\\
                    Update $M$ and $M_w$
                }
                % \If{$\lfloor N^n\rfloor > \lfloor N^{n-1} \rfloor$}
                % {
                %     Add point (Eq. \eqref{eq:addingPoint})\\
                %     Update $M$ and $M_w$
                % }
                % \ElseIf{$\lfloor N^n\rfloor < \lfloor N^{n-1} \rfloor$}
                % {
                %     Remove point (Eq. \eqref{eq:removingPoint})\\
                %     Update $M$ and $M_w$
                % }
                Calc. $\beta$ (Eq. \eqref{eq:betaDef})\\
                Update $\mathbf{B}$ and $\mathbf{C}_\pm$ (Eqs. \eqref{eq:bMat} and \eqref{eq:CMat})\\
                Calc. scheme (Eq. \eqref{eq:totalSystem})\\
                Retrieve output\\
                Update states ($\U^{n-1} = \U^n$, $\U^n = \U^{n+1}$)\\
                Update $N$ ($N^{n-1} = N^n$)\\
                Increment $n$
            \end{minipage} 
            % \begin{minipage}[c]{0.4\linewidth}
            % -\\
            % \vspace{2em}(Eq. \eqref{eq:addingPoint})\\
            
            % (Eq. \eqref{eq:removingPoint})\\

            % \end{minipage}
            }
        }
    }
    \vspace{0.12cm}
    \caption{Pseudocode showing the order of calculations.\label{alg:calcOrder}}
\end{algorithm}